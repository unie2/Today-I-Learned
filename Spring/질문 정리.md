### 💡 WAS(Web Application Server)와 WS(Web Server)의 차이
  - __WAS (Web Application Server)__
    - 비즈니스 로직을 넣을 수 있다.
    - Tomcat, PHP, ASP, .NET 등
  - __WS (Web Server)__
    - 비즈니스 로직을 넣을 수 없다.
    - Nginx, Apache 등

- - -
### 💡 Spring Framework이란 ?
  : 스프링 프레임워크는 자바 개발을 편리하게 해주는 오픈소스 프레임워크
#### 1. 경량 컨테이너로서 자바 객체를 직접 관리
  - 각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다.
#### 2. 제어의 역전(IoC) 이라는 기술을 통해 어플리케이션의 느슨한 결합을 도모
  - 컨트롤의 제어권이 사용자가 아닌 프레임워크에 있어서 필요에 따라 스프링에서 사용자의 코드를 호출한다.
  ```
  제어의 역전(Inversion of Control)
    - 제어의 역전이란 모든 객체에 대한(생성, 라이프사이클 등) 제어권을 개발자가 아닌 IoC 컨테이너에게 넘긴 것을 말한다.
    
    - 스프링에서는 IoC 컨테이너에 객체들을 생성하면 객체끼리 의존성을 주입하는 역할을 하고, 컨테이너에 등록한 객체들을 "빈"이라고 한다.
  ```
#### 3. [의존성 주입(DI, Dependency Injection)](#-의존성-주입Dependency-Injection)을 지원
  - 각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.
#### 4. 관점 지향 프로그래밍(AOP, Aspect-Oriented Programming)을 지원
  - 트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.
    
- - -
### 💡 @RequestBody, @RequestParam, @ModelAttribute의 차이
  - __@RequestBody__
    - 클라이언트가 전송하는 JSON 형태의 HTTP Body 내용을 MessageConverter를 통해 Java Object로 변환시켜주는 역할을 한다.
    - 값을 주입하지 않고 값을 변환시키므로(Reflection을 사용해 할당), 변수들의 생성자, Getter, Setter가 없어도 정상적으로 할당된다.
  - __@RequestParam__
    - 1개의 HTTP 요청 파라미터를 받기 위해 사용
    - `@RequestParam`은 필수 여부가 `true`이기 때문에, 기본적으로 반드시 해당 파라미터가 전송되어야 한다.
    - 전송되지 않으면 400 Error를 유발할 수 있으며, 반드시 필요한 변수가 아니라면 required의 값을 `false`로 설정해줘야 한다.
  - __@ModelAttribute__
    - HTTP Body 내용과 HTTP 파라미터의 값들을 생성자, Getter, Setter를 통해 주입하기 위해 사용
    - 값 변환이 아닌, 값을 주입시키므로 변수들의 생성자나 Getter, Setter가 없으면 변수들이 저장되지 않는다.

- - -
### 💡 Spring MVC란 ?
  : MVC는 Model, View, Controller의 약자이며, 각 레이어간 기능을 구분하는데 중점을 둔 디자인 패턴
  - __Model__
    - 데이터 관리 및 비즈니스 로직을 처리하는 부분
    - DAO, DTO, Service 등
  - __View__
    - 비즈니스 로직의 처리 결과를 통해 유저 인터페이스가 표현되는 구간
    - html, jsp, tymeleaf, mustache 등 화면을 구성하기도 하고, Rest API로 서버가 구현된다면 JSON 응답으로 구성되기도 한다.
  - __Controller__
    - 사용자의 요청을 처리하고 Model과 View를 중개하는 역할
    - `Model`과 `View`는 서로 연결되어 있지 않기 때문에 Controller가 사이에서 통신 매체가 되어준다.

- - -
### 💡 MVC 요청 처리 흐름
![MVC](https://user-images.githubusercontent.com/54324782/185782919-3bd732da-3da0-40e6-98b6-424b333d04c3.png)

#### 1. 클라이언트는 URL을 통해 요청을 전송
#### 2. Dispatcher Servlet은 Handler Mapping을 통해 해당 요청이 어느 컨트롤러에게 온 요청인지 찾는다.
#### 3. Dispatcher Servlet은 Handler Adapter에게 요청의 전달은 맡긴다.
#### 4. Handler Adapter는 해당 컨트롤러에 요청을 전달
#### 5. 컨트롤러는 비즈니스 로직을 처리한 후에 반환할 View의 이름을 반환
#### 6. Dispatcher Servlet은 View Resolver를 통해 반환할 View를 찾는다.
#### 7. Dispatcher Servlet은 컨트롤러에서 View에 전달할 데이터를 추가
#### 8. 데이터가 추가된 View를 반환

- - -
### 💡 스프링에서 빈(Bean)을 등록하는 방법
#### 1. 컴포넌트 스캔과 자동 의존관계 설정: `@Component 어노테이션` 사용
  - `@Controller`, `@Service`, `@Repository`는 모두 `@Component`를 포함하고 있다.
  - 해당 어노테이션으로 등록된 클래스들은 스프링 컨테이너에 의해 자동으로 생성되어 `스프링 빈`으로 등록된다.  
  ![@Component](https://user-images.githubusercontent.com/54324782/185783309-5a3ba2e5-a910-4d42-ac61-e0c86ce56b28.png)

#### 2. 자바 코드로 직접 스프링 빈 등록
  - 설정 클래스를 따로 만들어 `@Configuration 어노테이션`을 붙이고,
  - 해당 클래스 안에서 빈으로 등록할 메소드를 만들어 `@Bean 어노테이션`을 붙여주면 자동으로 해당 타입의 빈 객체가 생성된다.  
  ![@Configuration](https://user-images.githubusercontent.com/54324782/185783371-e80b2bc4-6e1a-4efe-838c-1256a6225697.png)

- - -
### 💡 의존성 주입(Dependency Injection)
: 의존성 주입은 필요한 객체를 직접 생성하는 것이 아닌 외부로부터 객체를 받아서 사용하는 것
  - 이를 통해 객체간의 결합도를 줄이고 코드의 재사용성을 높일 수 있다.
#### "의존성 주입을 해야 하는 이유"
  - Test가 용이해진다.
  - 코드의 재사용성을 높여준다.
  - 객체 간의 의존성(종속성)을 줄이거나 없앨 수 있다.
  - 객체 간의 결합도를 낮추면서 유연한 코드를 작성할 수 있다.
#### "의존성 주입 3가지 방법"
#### 1. 생성자 주입(Constructor Injection)
  - 클래스의 생성자가 하나이고, 그 생성자로 주입받을 객체가 빈으로 등록되어 있다면 `@Autowired` 생략 가능
  ````java
  @Controller
  public class MemberController {
      private final MemberService memberService;
      
      //@Autowired
      public MemberController(MemberService memberService) {
          this.memberService = memberService;
      }
  }
  
  ````
#### 2. 필드 주입(Field Injection)
  - 필드에 `@Autowired` 어노테이션만 붙여주면 자동으로 의존성 주입
  - 코드가 간결하지만, 외부에서 변경하기 힘들다.
  - 프레임워크에 의존적이고 객체지향적으로 좋지 않다.
  ````java
  @Controller
  public class MemberController {
      @Autowired
      private MemberService memberService;
  }
  
  ````
#### 3. 수정자 주입(Setter Injection)
  - `Setter` 메소드에 `@Autowired` 어노테이션을 붙이는 방법
  ````java
  @Controller
  public class MemberController {
      private MemberService memberService;
      
      @Autowired
      public void setMemberService(MemberService memberService) {
          this.memberService = memberService;
      }
  }
  
  ````
#### "어떤 주입 방식을 사용하는게 좋을까?"
: Spring Framework Reference에서 권장하는 방법은 `생정자를 통한 주입`
  - 순환 참조를 방지할 수 있기 때문
  ```
  - 필드 주입과 수정자 주입은 Bean이 생성된 후에 참조를 하기 때문에 어플리케이션이 아무런 오류 없이 구동된다.
  - 반면, 생성자를 통해 주입하고 실행하면 BeanCurrentlyInCreationException이 발생한다.
  - 순환 참조 뿐만아니라 의존 관계에 내용을 외부로 노출 시킴으로써 어플리케이션을 실행하는 시점에서 오류를 체크할 수 있다.
  ```
  - 불변성(Immutability) 보장이 가능하기 때문
  ```
  - 생성자로 의존성을 주입할 때 final로 선언할 수 있고, 이로 인해 런타임에서 의존성을 주입받는 객체가 변할 일이 없어지게 된다.
  - 반면, 수정자 주입이나 일반 메소드 주입을 이용하면 불필요하게 수정의 가능성을 열어두게 되고, 이는 "개방-폐쇄의 원칙"을 위반한다.
  ```
  - 테스트에 용이하기 때문
  ```
  - 생성자 주입을 사용하게 되면 테스트 코드를 좀 더 편리하게 작성할 수 있다.
  ```
  
- - -
### 💡 스프링 빈의 라이프사이클은 어떻게 관리되는지?
  ```스프링 IoC 컨테이너 생성 --> 스프링 빈 생성 --> 의존관계 주입 --> 초기화 콜백 메소드 호출 --> 소멸 전 콜백 메소드 호출 --> 스프링 종료
  ```
  - 스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메소드를 통해 초기화 시점을 알려준다.
  - 스프링 컨테이너가 종료되기 직전에도 소멸 콜백 메소드를 통해 소멸 시점을 알려준다.

#### 스프링 빈 라이프사이클을 압축시키기 위해 생성자 주입을 통해 빈 생성과 초기화를 동시에 진행한다면?
  - 초기화 작업이 내부 값들만 약간 변경하는 정도로 단순한 경우에는 생성자에서 한 번에 처리하는게 나을 수 있다.
  - 다만, 생성된 값들을 활용해 외부 커넥션을 연결하는 등 무거운 작업을 할 시에는 `객체를 생성하는 부분`과 `초기화하는 부분`을 명확하게 나눈 것이 유지보수 관점에서 좋다.

#### 빈 생명주기 콜백 관리 (3가지 방법)
  - 인터페이스(InitializingBean, DisposableBean)
    - `InitializingBean`은 afterPropertiesSet() 메소드로 초기화를 지원한다. (의존관계 주입이 끝난 후에 초기화 진행)
    - `DisposableBean`은 destroy() 메소드로 소멸을 지원한다. (Bean 종료 전에 마무리 작업 ex. 자원 해제(close() 등..))
    ````java
    public class ExampleBean implements InitializingBean, DisposableBean {
        @Override
        public void afterPropertiesSet() throws Exception {
            // 초기화 콜백 (의존관계 주입이 끝나면 호출)
        }
        
        @Override
        public void destroy() throws Exception {
            // 소멸 전 콜백 (메모리 반납, 연결 종료와 같은 과정)
        }
    }
    
    ````
    - __단점__
      - `InitializingBean`, `DisposableBean` 인터페이스는 스프링 전용 인터페이스이다. 해당 코드가 인터페이스에 의존한다.
      - 초기화, 소멸 메소드를 오버라이드하기 때문에 메소드명을 변경할 수 없다.
      - 코드를 커스터마이징할 수 없는 외부 라이브러리에 적용 불가능하다.
    
  - 설정 정보에 초기화 메소드, 종료 메소드 지정
    ````java
    public class ExampleBean {
        public void initialize() throws Exception {
            // 초기화 콜백 (의존관계 주입이 끝나면 호출)
        }
    
        public void close() throws Exception {
            // 소멸 전 콜백 (메모리 반납, 연결 종료와 같은 과정)
        }
    }
    
    Configuration
    class LifeCycleConfig {
        @Bean(initMethod = "initialize", destroyMethod = "close")
        public ExampleBean exampleBean() {
            // 생략
        }
    }
    ````
    - __장점__
      - 메소드명을 자유롭게 부여 가능하다.
      - 스프링 코드에 의존하지 않는다.
      - 설정 정보를 사용하기 때문에 코드를 커스터마이징할 수 없는 외부 라이브러리에서도 적용 가능하다.
    - __단점__
      - Bean 지정 시 `initMethod`와 `destroyMethod`를 직접 지정해야 하므로 번거롭다.
      
  - @PostConstruct, @PreDestroy 어노테이션 지원
    ````java
    import javax.annotation.PostConstruct;
    import javax.annotation.PreDestroy;
    
    public class ExampleBean {
        @PostConstruct
        public void initialize() throws Exception {
            // 초기화 콜백 (의존관계 주입이 끝나면 호출)
        }
        
        @PreDestroy
        public void close() throws Exception {
            // 소멸 전 콜백 (메모리 반납, 연결 종료와 같은 과정)
        }
    }
    
    ````
    - __장점__
      - 최신 스프링에서 가장 권장하는 방법
      - 어노테이션 하나만 붙이면 되므로 매우 편리하다.
      - 패키지가 javax.annotation.xxx이다. 스프링에 종속적인 기술이 아닌 `JSR-250`이라는 자바 표준이다.
        따라서 스프링이 아닌 다른 컨테이너에서도 동작한다.
      - 컴포넌트 스캔과 잘어울린다.
    - __단점__
      - 커스터마이징이 불가능한 외부 라이브러리에서 적용이 불가능하다.
      - 외부 라이브러리에서 초기화, 종료를 해야할 경우 `2번째 방법: @Bean의 initMethod와 destroyMethod` 속성을 사용!

- - -
### 💡 빈 생명주기(Bean LifeCycle) 콜백
#### 빈 생명주기 콜백의 필요성
```
콜백
  - 주로 콜백함수를 부를 때 사용되는 용어
  - 콜백함수를 등록하면 특정 이벤트가 발생했을 때 해당 메소드가 호출된다.
  - 즉, 조건에 따라 실행될 수도 실행되지 않을 수도 있는 개념
```
  - 스프링 빈은 초기화 작업과 종료 작업이 나눠서 진행된다. (객체 생성 -> 의존관계 주입)
  - 즉, 스프링 빈은 의존관계 주입이 다 끝난 다음에야 필요한 데이터를 사용할 수 있는 준비가 완료된다.

#### 의존성 주입 과정
1. Spring IoC 컨테이너 생성
  - SpringBoot에서 `Component-Scan`으로 Bean 등록을 시작하는 과정
  ![Spring IoC 컨테이너 생성](https://user-images.githubusercontent.com/54324782/186845095-c5c0096a-c0a7-42c3-8d54-7bb869b28cf0.png)
2. 객체 생성 및 의존 관계 주입
  ```
  - 생성자 주입 : 객체의 생성과 의존관계 주입이 동시에 일어남
  - Setter, Field 주입 : 객체의 생성 --> 의존관계 주입으로 라이프 사이클이 나누어져 있음
  ```
  - `생성자 주입`을 통해 얻는 이점
    - null을 주입하지 않는 한 `NullPointerException`은 발생하지 않는다.
    - 의존 관계를 주입하지 않은 경우 객체를 생성할 수 없으므로, 의존관계에 대한 내용을 외부로 노출시킴으로써 컴파일 타임에 오류를 잡아낼 수 있다.




- - -
#### 📖참고자료
https://dev-coco.tistory.com/163
